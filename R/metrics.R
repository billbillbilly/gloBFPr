#' @name get_metrics
#' @title get_metrics
#' @param x sf. building footprint polygon, typically output from [get_3dglobdf()]
#' @note
#' `x` must include a unique `id` field.
#' @references
#' Anna Labetski, Stelios Vitalis, Filip Biljecki, Ken Arroyo Ohori &
#' Jantien Stoter (2023): 3D building metrics for urban morphology.
#' International Journal of Geographical Information Science, 37(1):
#' 36-67. DOI: 10.1080/13658816.2022.2103818
#'
#' Rachid Hamaina, Thomas Leduc, Guillaume Moreau.
#' Towards Urban Fabrics Characterization Based on Buildings Footprints.
#' Jérôme Gensel; Didier Josselin; Danny Vandenbroucke.
#' Bridging the Geographic Information Sciences- International AGILE’2012 Conference,
#' Avignon (France), April, 24-27, 2012, Springer Berlin Heidelberg,
#' pp.327-346, 2012, 978-3-642-29062-6. 10.1007/978-3-642-290633_18. hal-01347299
#'
#' Melchiorri, M., Freire, S., Schiavina, M. et al.
#' The Multi-temporal and Multi-dimensional Global Urban Centre Database to
#' Delineate and Analyse World Cities. Sci Data 11, 82 (2024).
#' https://doi.org/10.1038/s41597-023-02691-1
#'
#' @importFrom terra as.points viewshed cellSize ifel
#' @importFrom sf st_as_sf st_nearest_feature st_distance st_centroid st_coordinates st_area
#' @importFrom sf st_minimum_rotated_rectangle st_perimeter
#' @importFrom terra merge


#' @description
#' `get_morphology`: Computes a set of morphological properties and geometric descriptors for each building footprint polygon.
#' These include area, perimeter, surface area, volume, shape compactness, elongation, and accessibility measures.
#'
#' @return
#' `get_morphology` returns an `sf` object identical to input \code{x},
#' with additional columns for:
#' \itemize{
#'  \item \code{g_area}: Ground area of footprint
#'  \item \code{pmeter}: Perimeter length of footprint
#'  \item \code{v_surf}: Vertical surface area (walls)
#'  \item \code{t_surf}: Total surface area (walls + roof)
#'  \item \code{vol}: Volume (area * height)
#'  \item \code{obb_vol}: Volume of oriented bounding box
#'  \item \code{pa_ratio}: Perimeter-area ratio
#'  \item \code{rec}: Rectangular compactness
#'  \item \code{fra}: Fractal dimension ratio
#'  \item \code{cbn}: Cuboidness index
#'  \item \code{hem}: Hemisphericality index
#'  \item \code{cnv}: Convexity index
#'  \item \code{me_dist}: Mean edge accessibility distance
#'  \item \code{mp_dist}: Mean pairwise distance within the footprint
#'  \item \code{vol_exch}: Volume exchange ratio
#'  \item \code{elo_short/elo_long}: Elongation ratios (short/long axis)
#' }
#'
#' @examples
#' data(globfp_example)
#' result <- gloBFPr::get_morphology(buildings)
#'
#' @export
#' @rdname get_metrics
get_morphology <- function(x = NULL) {
  if (missing(x)) {
    stop("Please input building footprint polygon generated by `search_3dglobdf`")
  }
  projected_poly <- x
  start_time <- Sys.time()

  #### Properties ####
  projected_poly$g_area <- as.numeric(sf::st_area(projected_poly))
  projected_poly$pmeter <- as.numeric(sf::st_perimeter(projected_poly))
  projected_poly$v_surf <- projected_poly$pmeter * projected_poly$Height
  projected_poly$t_surf <- projected_poly$v_surf + projected_poly$g_area
  projected_poly$vol <- projected_poly$g_area * projected_poly$Height
  projected_poly$obb_vol <- as.numeric(sf::st_area(sf::st_minimum_rotated_rectangle(projected_poly)) * projected_poly$Height)

  #### Indices ####
  projected_poly$pa_ratio <- projected_poly$pmeter / projected_poly$g_area # Perimeter-Area Ratio
  projected_poly$rec <- as.numeric(projected_poly$g_area / sf::st_area(sf::st_minimum_rotated_rectangle(projected_poly)))
  projected_poly$fra <- 1 - log(projected_poly$vol + 1e-9) / (1.5 * log(projected_poly$t_surf + 1e-9))
  projected_poly$cbn <- 6 * (projected_poly$vol^2)^(1/3) / projected_poly$t_surf

  projected_poly$hem <- 0
  projected_poly$cnv <- 0
  projected_poly$me_dist <- 0
  projected_poly$mp_dist <- 0
  projected_poly$vol_exch <- 0
  projected_poly$elo_x <- 0
  projected_poly$elo_y <- 0
  projected_poly$elo_z <- 0
  for (i in seq_len(nrow(projected_poly))) {
    poly_ <- projected_poly[i,]
    projected_poly$hem[i] <- cal_hemisphericality(poly_)
    projected_poly$cnv[i] <- cal_convexity(poly_)
    projected_poly$me_dist[i] <- cal_accessibility(poly_)
    projected_poly$mp_dist[i] <- cal_mean_pairwise_distance(poly_)
    projected_poly$vol_exch[i] <- cal_volume_exchange_ratio(poly_)
    elongation_ratios <- cal_elongation_ratios(poly_)
    projected_poly$elo_x[i] <- elongation_ratios[[1]]
    projected_poly$elo_y[i] <- elongation_ratios[[2]]
    projected_poly$elo_z[i] <- elongation_ratios[[3]]
  }
  end_time <- Sys.time()
  process_time <- as.numeric(difftime(end_time, start_time, units = "secs"))
  cli::cli_alert_success(paste0("Completed. Time taken: ", base::round(process_time/60), " minutes."))
  return(projected_poly)
}

#' @description
#' `get_pop_density`: Downloads and extracts population density data from the GHSL
#' (Global Human Settlement Layer) dataset for a specified year, and assigns
#' population density values to each input building polygon based on its
#' centroid location.
#'
#' @param year numeric. (only required for `get_pop_density`) Year of the GHSL
#' dataset to use. Must be one of: 1975, 1980, 1985, 1990, 1995, 2000, 2005,
#' 2010, 2015, 2020, 2025, or 2030. Default is 2025.
#'
#' @return
#' `get_pop_density` returns an `sf` object identical to input \code{x},
#' with an added column:
#' \itemize{
#'   \item \code{pop_den}: Estimated population density (people per 10000m²)
#'   at the centroid of each building polygon.
#' }
#'
#' @examples
#' result <- gloBFPr::get_pop_density(buildings, year = 2025)
#'
#'
#' @export
#' @rdname get_metrics
get_pop_density <- function(x = NULL, year = 2025) {
  if (missing(x)) {
    stop("Please input building footprint polygon generated by `search_3dglobdf`")
  }
  bbox <- get_bbox(x)
  projected_poly <- x

  d_mode <- 'auto'
  # check os
  os <- Sys.info()[["sysname"]]
  if (os == "Windows") {
    d_mode <- 'wb'
  }
  # GHS population grid
  years <- c(2030, 2025, 2020, 2015, 2010, 2005, 2000, 1995, 1990, 1985, 1980, 1975)
  result_list <- list()
  if (year %in% years) {
    intersected_tiles <- ghsl_tiles[sf::st_intersects(ghsl_tiles, bbox, sparse = FALSE), ]
    for (i in seq_len(nrow(intersected_tiles))) {
      temp_zip <- tempfile(fileext = ".zip")
      utils::download.file(intersected_tiles$tile_id[i],
                           destfile = temp_zip,
                           mode = d_mode,
                           quiet = TRUE)
      unzip_dir <- tempfile()
      utils::unzip(temp_zip, exdir = unzip_dir)
      tif_files <- list.files(unzip_dir, pattern = "\\.tif$", full.names = TRUE)
      if (length(tif_files) == 0) next
      rast_data <- terra::rast(tif_files[1])
      result_list[[length(result_list) + 1]] <- rast_data
      unlink(c(temp_zip, unzip_dir), recursive = TRUE)
    }

    if (length(result_list) == 0) {
      base::warning("No population rasters downloaded. Returning original polygons.")
      return(projected_poly)
    }

    # Combine all into one terra raster object
    r <- if (length(result_list) == 1) result_list[[1]] else do.call(terra::merge, result_list)

    # reproject raster
    utm_crs <- get_utm_crs(bbox)
    r <- terra::project(r, paste0('EPSG:', utm_crs))

    # calculate population density
    r <- r / (100*100)

    # use all centroids of projected_poly to extract value from the raster
    pop_vals <- terra::extract(r, terra::vect(sf::st_centroid(projected_poly)),
                               raw = TRUE,
                               ID = FALSE)[, 1]
    # link pop_density_df back to projected_poly
    projected_poly$pop_den <- pop_vals

  } else {
    base::warning(sprintf("Input year %d is not in allowed range. Skipping.", year))
    return(projected_poly)
  }
  return(projected_poly)
}

#' @description
#' `get_neighbors`: Computes the number of neighboring buildings and their average and standard
#' deviation of centroid distances, based on a fixed-radius buffer and
#' Voronoi-based adjacency. Useful for understanding local building density and
#' spacing.
#'
#' @param radius numeric. (only required for `get_neighbors`) A numeric value
#' specifying the buffer radius (meters) used to define local neighborhoods.
#'
#' @return
#' `get_neighbors` returns an `sf` object identical to input \code{x},
#' with additional columns for:
#' \itemize{
#'   \item \code{n_count}: Number of adjacent buildings within the radius.
#'   \item \code{m_ndist}: Mean distance from the building centroid
#'   to neighboring building centroids.
#'   \item \code{sd_ndist}: Standard deviation of those distances.
#' }
#'
#'
#' @examples
#' result <- gloBFPr::get_neighbors(buildings, radius = 300)
#'
#' @export
#' @rdname get_metrics
get_neighbors <- function(x = NULL, radius = 500) {
  if (missing(x)) {
    stop("Please input building footprint polygon generated by `search_3dglobdf`")
  }
  projected_poly <- x
  projected_poly$n_count <- 0
  projected_poly$m_ndist <- NA
  projected_poly$sd_ndist <- NA

  for (i in seq_len(nrow(projected_poly))) {
    poly_ <- projected_poly[i, ]

    # Buffer around centroid
    this_centroid <- sf::st_centroid(poly_)
    buffer_zone <- sf::st_buffer(this_centroid, dist = radius)
    buffer_zone <- sf::st_transform(buffer_zone, sf::st_crs(projected_poly))

    # Filter by intersection with buffer
    intersection_mat <- sf::st_intersects(projected_poly, buffer_zone, sparse = FALSE)[, 1]
    if (sum(intersection_mat) <= 1) next  # only self or no neighbors

    filtered_poly <- projected_poly[intersection_mat, ]
    filtered_centroids <- sf::st_centroid(filtered_poly)

    # Voronoi tessellation from filtered centroids
    centroid_union <- sf::st_union(filtered_centroids)
    voronoi_polygons <- sf::st_voronoi(centroid_union) |>
      sf::st_collection_extract("POLYGON")
    voronoi_sf <- sf::st_sf(geometry = sf::st_sfc(voronoi_polygons),
                            crs = sf::st_crs(filtered_poly))
    voronoi_sf$id <- seq_len(nrow(filtered_poly))

    # Find index of current polygon in filtered_poly
    index_in_filtered <- which(filtered_poly$id == poly_$id)
    if (length(index_in_filtered) == 0) next

    # Adjacency based on touching Voronoi cells
    adjacency_matrix <- sf::st_touches(voronoi_sf)
    neighbor_indices <- adjacency_matrix[[index_in_filtered]]

    # Distance computation
    if (length(neighbor_indices) > 0) {
      neighbor_centroids <- filtered_centroids[neighbor_indices, ]
      dists <- sf::st_distance(this_centroid, neighbor_centroids)
      projected_poly$n_count[i] <- length(neighbor_indices)
      projected_poly$m_ndist[i] <- mean(as.numeric(dists))
      if (length(neighbor_indices) != 1) {
        projected_poly$sd_ndist[i] <- sd(as.numeric(dists))
      } else {
        projected_poly$sd_ndist[i] <- NA
      }
    }
  }
  return(projected_poly)
}

#' @description
#' `get_green_acc`: Calculate visual and distance accessibility of greenery for each building volume
#' @param min_tree_height numeric. (only required for `get_green_acc`)
#' Minimum height threshold (in meters) to classify vegetation as trees in the CHM.
#' Default is 2.
#' @param floor logical. (only required for `get_green_acc`) Whether to compute
#' Green View Index (GVI) for each floor level based on estimated number of floors.
#' Default is `FALSE`.
#' for each floor of a building volume. Default is `FALSE`.
#' @param key character. (only required for `get_green_acc`) API key of OpenTopography.
#'
#' @return
#' `get_neighbors` returns an `sf` object identical to input \code{x},
#' with additional columns for:
#' \itemize{
#'   \item \code{dng}: Distance to nearest green space (tree canopy pixe)l (in meters).
#'   \item \code{mean_gvi}: Mean Green View Index value (0 to 1) from selected height(s).
#'   \item \code{min_gvi}, \code{max_gvi}, \code{sd_gvi}: Minimum, maximum,
#'   and standard deviation of Green View Index (GVI) (if \code{floor = TRUE}).
#'   \item \code{g_area}: Ground area of each building footprint (in square meters).
#'   \item \code{estimated_floors}: Estimated number of floors based on building height
#'   (if \code{floor = TRUE}).
#'}
#'
#' @note
#' USGS 3DEP 1m/10m raster dataset is currently restricted to academic users.
#' Academic users can request access to these data via the OpenTopography portal.
#' Non-academic users can enquire about an enterprise API key by emailing info@opentopography.org.
#' See OpenTopography Terms of Use for more information on appropriate use of the API.
#'
#'
#' @examples
#' \donttest{
#' result <- gloBFPr::get_green_acc(projected_buildings, key = "YOUR_opentopography_API_KEY")
#' }
#'
#' @export
#' @rdname get_metrics
get_green_acc <- function(x = NULL,
                          min_tree_height = 2,
                          floor = FALSE,
                          key = NULL) {
  if (inherits(x, 'NULL')) {
    stop('Please input building footprint polygon generated by `search_3dglobdf`.')
  }

  if (inherits(key, 'NULL')) {
    stop('API key of opentopography is missing.')
  }

  start_time <- Sys.time()
  bbox <- get_bbox(x)
  chm_layers <- get_chm(bbox, min_tree_height)
  projected_poly <- x

  #### distance to the nearest green space (DNG) ####
  # convert tree raster into points
  green_points <- terra::as.points(chm_layers[[2]], na.rm = TRUE)
  green_points_sf <- sf::st_as_sf(green_points)
  building_centroids <- sf::st_centroid(x)
  green_points_sf <- sf::st_transform(green_points_sf, crs = sf::st_crs(x))
  # distance to the nearest green space pixel
  nearest_index <- sf::st_nearest_feature(building_centroids, green_points_sf)
  nearest_points <- green_points_sf[nearest_index, ]
  distances <- sf::st_distance(building_centroids, nearest_points, by_element = TRUE)
  projected_poly$dng <- as.numeric(distances)

  #### green view index (GVI) ####
  dem <- get_dem(bbox, key)
  # precompute DSM once (DEM + CHM)
  chm_n_dem <- unify_layers(bbox, chm_layers[[1]], dem)
  chm <- chm_n_dem[[1]]
  binary_chm <- chm_layers[[2]]
  dem <- chm_n_dem[[2]]

  projected_poly$g_area <- as.numeric(sf::st_area(projected_poly))

  # estimate floor number if 'floor' is true
  if (isTRUE(floor)) {
    projected_poly$estimated_floors <- round(projected_poly$Height / 3)
    projected_poly$estimated_floors <- base::ifelse(projected_poly$g_area < 30 || projected_poly$Height < 6,
                                                    1,
                                                    projected_poly$estimated_floors)
    projected_poly$min_gvi <- 0
    projected_poly$max_gvi <- 0
    projected_poly$sd_gvi <- 0
  }
  projected_poly$mean_gvi <- 0

  # loop
  for (i in seq_len(nrow(projected_poly))) {
    building <- projected_poly[i,]
    viewpoint <- sf::st_centroid(building$geometry)
    viewpoint <- as.vector(sf::st_coordinates(viewpoint))

    bh <- rasterize_height(projected_poly[-c(i),], bbox, terra::res(dsm))
    chm_n_bh <- unify_layers(bbox, chm, bh)
    bh <- chm_n_bh[[2]]
    dsm <- bh + chm + dem

    GVIs <- c()
    p <- cbind(viewpoint[1], viewpoint[2])
    if (isTRUE(floor)) {
      for (h in 1:building$estimated_floors) {
        height <- 1.7 + (h - 1) * 3
        gvi <- get_gvi(dsm, p, height, building, binary_chm)
        GVIs <- c(GVIs, gvi)
      }
      projected_poly$mean_gvi[i] <- mean(GVIs)
      projected_poly$min_gvi[i] <- min(GVIs)
      projected_poly$max_gvi[i] <- max(GVIs)
      projected_poly$sd_gvi[i] <- if (length(GVIs) > 1) sd(GVIs) else NA
    } else {
      height_buttom <- 1.7
      if (building$Height < 6) {
        projected_poly$mean_gvi[i] <- get_gvi(dsm, p, height_buttom, building, binary_chm)
      } else {
        height_top <- 1.7 + building$Height - 3
        gvi_top <- get_gvi(dsm, p, height_top, building, binary_chm)
        gvi_buttom <- get_gvi(dsm, p, height_buttom, building, binary_chm)
        projected_poly$mean_gvi[i] <- mean(c(gvi_top, gvi_buttom))
      }
    }
  }
  end_time <- Sys.time()
  process_time <- as.numeric(difftime(end_time, start_time, units = "secs"))
  cli::cli_alert_success(paste0("Completed. Time taken: ", base::round(process_time/60), " minutes."))
  return(projected_poly)
}
