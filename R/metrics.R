#' @name get_metrics
#' @title get_metrics
#' @description
#' calculate building morphologic properties and corresponding indicators
#'
#' @param x sf. building footprint polygon, typically output from [get_3dglobdf()]
#'
#' @return `sf`
#'
#' @details
#'
#' @examples
#' # example code
#'
#'
#' @reference
#' Anna Labetski, Stelios Vitalis, Filip Biljecki, Ken Arroyo Ohori &
#' Jantien Stoter (2023): 3D building metrics for urban morphology.
#' International Journal of Geographical Information Science, 37(1):
#' 36-67. DOI: 10.1080/13658816.2022.2103818
#'
#' Rachid Hamaina, Thomas Leduc, Guillaume Moreau.
#' Towards Urban Fabrics Characterization Based on Buildings Footprints.
#' Jérôme Gensel; Didier Josselin; Danny Vandenbroucke.
#' Bridging the Geographic Information Sciences- International AGILE’2012 Conference,
#' Avignon (France), April, 24-27, 2012, Springer Berlin Heidelberg,
#' pp.327-346, 2012, 978-3-642-29062-6. 10.1007/978-3-642-290633_18. hal-01347299
#'
#' Melchiorri, M., Freire, S., Schiavina, M. et al.
#' The Multi-temporal and Multi-dimensional Global Urban Centre Database to
#' Delineate and Analyse World Cities. Sci Data 11, 82 (2024).
#' https://doi.org/10.1038/s41597-023-02691-1
#'
#' @export
#' @rdname get_metrics
get_morphology <- function(x = NULL) {
  if (missing(x)) {
    stop("Please input building footprint polygon generated by `search_3dglobdf`")
  }
  projected_poly <- x
  #### Stats ####
  projected_poly$g_vcount <- nrow(sf::st_coordinates(projected_poly)) - 1

  #### Properties ####
  projected_poly$g_area <- as.numeric(sf::st_area(projected_poly))
  projected_poly$pmeter <- as.numeric(sf::st_perimeter(projected_poly))
  projected_poly$v_surf <- projected_poly$pmeter * projected_poly$Height
  projected_poly$t_surf <- projected_poly$v_surf + projected_poly$g_area
  projected_poly$vol <- projected_poly$g_area * projected_poly$Height
  projected_poly$obb_vol <- sf::st_area(sf::st_minimum_rotated_rectangle(projected_poly)) * projected_poly$Height

  #### Indices ####
  projected_poly$pa_ratio <- projected_poly$pmeter / projected_poly$g_area # Perimeter-Area Ratio
  projected_poly$rec <- projected_poly$g_area / sf::st_area(sf::st_minimum_rotated_rectangle(projected_poly))
  projected_poly$fra <- 1 - log(projected_poly) / (1.5 * log(projected_poly$t_surf))
  projected_poly$hem <- 0
  projected_poly$cnv <- 0
  projected_poly$cbn <- 0
  projected_poly$me_dist <- 0
  projected_poly$mp_dist <- 0
  projected_poly$vol_exch <- 0
  projected_poly$elo_short <- 0
  projected_poly$elo_long <- 0
  for (i in seq_len(nrow(projected_poly))) {
    poly_ <- projected_poly[i,]
    projected_poly$hem[i] <- cal_hemisphericality(poly_)
    projected_poly$cnv[i] <- cal_convexity(poly_)
    projected_poly$cbn[i] <- cal_cuboidness(poly_)
    projected_poly$me_dist[i] <- cal_accessibility(poly_)
    projected_poly$mp_dist[i] <- cal_mean_pairwise_distance(poly_)
    projected_poly$vol_exch[i] <- cal_volume_exchange_ratio(poly_)
    elongation_ratios <- cal_elongation_ratios(poly_)
    projected_poly$elo_short[i] <- elongation_ratios[[1]]
    projected_poly$elo_long[i] <- elongation_ratios[[2]]
  }
  return(projected_poly)
}

#' @description
#' A short description...
#'
#' @param year numeric. The default is 2025
#' @export
#' @rdname get_metrics
get_pop_density <- function(x = NULL, year = 2025) {
  if (missing(x)) {
    stop("Please input building footprint polygon generated by `search_3dglobdf`")
  }
  bbox <- get_bbox(x)
  projected_poly <- x

  d_mode <- 'auto'
  # check os
  os <- Sys.info()[["sysname"]]
  if (os == "Windows") {
    d_mode <- 'wb'
  }
  # GHS population grid
  years <- c(2030, 2025, 2020, 2015, 2010, 2005, 2000, 1995, 1990, 1985, 1980, 1975)
  result_list <- list()
  if (year %in% years) {
    intersected_tiles <- ghsl_tiles[sf::st_intersects(ghsl_tiles, bbox, sparse = FALSE), ]
    for (i in seq_len(nrow(intersected_tiles))) {
      temp_zip <- tempfile(fileext = ".zip")
      utils::download.file(intersected_tiles$tile_id[i],
                           destfile = temp_zip,
                           mode = d_mode,
                           quiet = TRUE)
      unzip_dir <- tempfile()
      utils::unzip(temp_zip, exdir = unzip_dir)
      tif_files <- list.files(unzip_dir, pattern = "\\.tif$", full.names = TRUE)
      if (length(tif_files) == 0) next
      rast_data <- terra::rast(tif_files[1])
      result_list[[length(result_list) + 1]] <- rast_data
      unlink(c(temp_zip, unzip_dir), recursive = TRUE)
    }

    if (length(result_list) == 0) {
      base::warning("No population rasters downloaded. Returning original polygons.")
      return(projected_poly)
    }

    # Combine all into one terra raster object
    r <- if (length(result_list) == 1) result_list[[1]] else do.call(terra::merge, result_list)

    # reproject raster
    utm_crs <- get_utm_crs(bbox)
    r <- terra::project(r, paste0('EPSG:', utm_crs))

    # calculate population density
    r <- r / (100*100)

    # use all centroids of projected_poly to extract value from the raster
    pop_density_df <- terra::extract(r,
                                     terra::vect(sf::st_centroid(projected_poly)),
                                     ID = FALSE)
    # link pop_density_df back to projected_poly
    projected_poly$pop_density <- pop_density_df[[1]]

  } else {
    base::warning(sprintf("Input year %d is not in allowed range. Skipping.", year))
    return(projected_poly)
  }
  return(projected_poly)
}

#' @description
#' A short description...
#'
#' @param radius numeric.
#' @export
#' @rdname get_metrics
get_neighbors <- function(x = NULL, radius = 500) {
  if (missing(x)) {
    stop("Please input building footprint polygon generated by `search_3dglobdf`")
  }
  projected_poly <- x
  projected_poly$neighbor_count <- 0
  projected_poly$mean_neighbor_distance <- NA
  projected_poly$sd_neighbor_distance <- NA

  for (i in seq_len(nrow(projected_poly))) {
    poly_ <- projected_poly[i, ]

    # Buffer around centroid
    this_centroid <- sf::st_centroid(poly_)
    buffer_zone <- sf::st_buffer(this_centroid, dist = radius)
    buffer_zone <- sf::st_transform(buffer_zone, sf::st_crs(projected_poly))

    # Filter by intersection with buffer
    intersection_mat <- sf::st_intersects(projected_poly, buffer_zone, sparse = FALSE)[, 1]
    if (sum(intersection_mat) <= 1) next  # only self or no neighbors

    filtered_poly <- projected_poly[intersection_mat, ]
    filtered_centroids <- sf::st_centroid(filtered_poly)

    # Voronoi tessellation from filtered centroids
    centroid_union <- sf::st_union(filtered_centroids)
    voronoi_polygons <- sf::st_voronoi(centroid_union) |>
      sf::st_collection_extract("POLYGON")
    voronoi_sf <- sf::st_sf(geometry = sf::st_sfc(voronoi_polygons),
                            crs = sf::st_crs(filtered_poly))
    voronoi_sf$id <- seq_len(nrow(filtered_poly))

    # Find index of current polygon in filtered_poly
    index_in_filtered <- which(filtered_poly$id == poly_$id)
    if (length(index_in_filtered) == 0) next

    # Adjacency based on touching Voronoi cells
    adjacency_matrix <- sf::st_touches(voronoi_sf)
    neighbor_indices <- adjacency_matrix[[index_in_filtered]]

    # Distance computation
    if (length(neighbor_indices) > 0) {
      neighbor_centroids <- filtered_centroids[neighbor_indices, ]
      dists <- sf::st_distance(this_centroid, neighbor_centroids)
      projected_poly$neighbor_count[i] <- length(neighbor_indices)
      projected_poly$mean_neighbor_distance[i] <- mean(as.numeric(dists))
      if (length(neighbor_indices) != 1) {
        projected_poly$sd_neighbor_distance[i] <- sd(as.numeric(dists))
      } else {
        projected_poly$sd_neighbor_distance[i] <- NA
      }
    }
  }
  return(projected_poly)
}

#' @description
#' Calculate visual and distance accessibility of greenery for each building volume
#' @param min_tree_height numeric. minimum height of trees for filter CHM. (default to 2m)
#' @param floor logical. whether use estimated floor number to assess viewshed
#' for each floor of a building volume.
#' @param key character. (required) API key of OpenTopography.
#'
#' @note
#' USGS 3DEP 1m/10m raster dataset is currently restricted to academic users.
#' Academic users can request access to these data via the OpenTopography portal.
#' Non-academic users can enquire about an enterprise API key by emailing info@opentopography.org.
#' See OpenTopography Terms of Use for more information on appropriate use of the API.
#'
#' @importFrom terra as.points viewshed cellSize ifel
#' @importFrom sf st_as_sf st_nearest_feature st_distance st_centroid st_coordinates
#'
#' @export
#' @rdname get_metrics
get_green_acc <- function(x = NULL,
                          min_tree_height = 2,
                          floor = FALSE,
                          key = NULL) {
  bbox <- get_bbox(x)
  chm_layers <- get_chm(bbox, min_tree_height)
  projected_poly <- x

  #### distance to the nearest green space (DNG) ####
  # convert tree raster into points
  green_points <- terra::as.points(chm_layers[[2]], na.rm = TRUE)
  green_points_sf <- sf::st_as_sf(green_points)
  building_centroids <- sf::st_centroid(x)
  green_points_sf <- sf::st_transform(green_points_sf, crs = sf::st_crs(x))
  # distance to the nearest green space pixel
  nearest_index <- sf::st_nearest_feature(building_centroids, green_points_sf)
  nearest_points <- green_points_sf[nearest_index, ]
  distances <- sf::st_distance(building_centroids, nearest_points, by_element = TRUE)
  projected_poly$dng <- as.numeric(distances)

  #### green view index (GVI) ####
  dem <- get_dem(bbox, key)
  # merge dem and chm layers to generate dsm
  chm_n_dem <- unify_layers(bbox, chm_layers[[1]], dem)
  chm <- chm_n_dem[[1]]
  binary_chm <- chm_layers[[2]]
  dem <- chm_n_dem[[2]]

  projected_poly$g_area <- as.numeric(sf::st_area(projected_poly))

  # estimate floor number if 'floor' is true
  if (isTRUE(floor)) {
    projected_poly$estimated_floors <- round(projected_poly$Height / 3)
    projected_poly$estimated_floors <- base::ifelse(projected_poly$g_area < 30 || buildings$Height < 6,
                                                    1,
                                                    projected_poly$estimated_floors)
    projected_poly$min_gvi <- 0
    projected_poly$max_gvi <- 0
    projected_poly$sd_gvi <- 0
  }
  projected_poly$mean_gvi <- 0

  # loop
  for (i in seq_len(nrow(projected_poly))) {
    building <- projected_poly[i,]
    viewpoint <- sf::st_centroid(building$geometry)
    viewpoint <- as.vector(sf::st_coordinates(viewpoint))

    bh <- rasterize_height(projected_poly[-c(i),], bbox, terra::res(dsm))
    chm_n_bh <- unify_layers(bbox, chm, bh)
    bh <- chm_n_dem[[2]]
    dsm <- bh + chm + dem

    GVIs <- c()
    p <- cbind(viewpoint[1], viewpoint[2])
    if (isTRUE(floor)) {
      for (h in 1:building$estimated_floors) {
        height <- 1.7 + (h - 1) * 3
        gvi <- get_gvi(dsm, p, height, building, binary_chm)
        GVIs <- c(GVIs, gvi)
      }
      projected_poly$mean_gvi[i] <- mean(GVIs)
      projected_poly$min_gvi[i] <- min(GVIs)
      projected_poly$max_gvi[i] <- max(GVIs)
      if (length(GVIs) == 1) {
        projected_poly$sd_gvi[i] <- NA
      } else {
        projected_poly$sd_gvi[i] <- sd(GVIs)
      }
    } else {
      if (buildings$Height < 6) {
        height_buttom <- 1.7
        projected_poly$mean_gvi[i] <- get_gvi(dsm, p, height_buttom, building, binary_chm)
      } else {
        height_top <- 1.7 + building$Height - 3
        height_buttom <- 1.7
        gvi_top <- get_gvi(dsm, p, height_top, building, binary_chm)
        gvi_buttom <- get_gvi(dsm, p, height_buttom, building, binary_chm)
        projected_poly$mean_gvi[i] <- mean(c(gvi_top, gvi_buttom))
      }
    }
  }
  return(projected_poly)
}
